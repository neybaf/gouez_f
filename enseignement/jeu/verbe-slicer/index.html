<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verbe Slicer - Version Simple</title>
    <!-- CSS AUTONOME - Pas de d√©pendances externes -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            color: white;
            overflow: hidden;
        }
        
        /* Debug styles */
        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 2000;
            max-width: 300px;
            border: 1px solid #333;
        }
        .debug-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin: 2px;
            font-size: 11px;
        }
        
        /* √âCRANS DE JEU - DESIGN NOIR */
        .game-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            z-index: 100;
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 50%, #000000 100%);
            color: white;
            overflow: hidden;
        }
        
        .game-screen.active {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        .game-screen.overlay.active {
            display: flex !important;
            align-items: center;
            justify-content: center;
        }
        
        /* √âCRAN DE D√âMARRAGE */
        #start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: radial-gradient(ellipse at center, #1a1a1a 0%, #000000 100%);
        }
        
        .game-header {
            margin-bottom: 40px;
        }
        
        .game-title {
            font-size: 4rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradient 3s ease infinite;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
        }
        
        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .title-icon {
            font-size: 3rem;
            margin-right: 20px;
        }
        
        .game-subtitle {
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 30px;
        }
        
        /* BOUTONS */
        .game-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            margin: 10px;
            min-width: 200px;
        }
        
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .game-btn.primary {
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            box-shadow: 0 6px 25px rgba(255, 107, 107, 0.4);
            font-size: 1.3rem;
            padding: 20px 40px;
            animation: pulse-glow 2s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 6px 25px rgba(255, 107, 107, 0.4); }
            50% { box-shadow: 0 8px 35px rgba(255, 107, 107, 0.7); }
        }
        
        /* S√âLECTEUR DE DIFFICULT√â */
        .difficulty-selector {
            margin: 30px 0;
        }
        
        .difficulty-selector h3 {
            margin-bottom: 20px;
            color: #ccc;
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .difficulty-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            min-width: 120px;
        }
        
        .difficulty-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .difficulty-btn.active {
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            border-color: #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
        }
        
        .difficulty-icon {
            font-size: 1.5rem;
            display: block;
            margin-bottom: 5px;
        }
        
        /* √âCRAN DE JEU */
        #game-screen {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
        }
        
        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
        }
        
        .ui-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .score-display, .level-display {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .score-value, .level-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .level-name {
            font-size: 0.9rem;
            color: #888;
            display: block;
        }
        
        .lives-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .lives-hearts {
            display: flex;
            gap: 5px;
        }
        
        .heart {
            font-size: 1.5rem;
            transition: all 0.3s ease;
        }
        
        .heart.lost {
            opacity: 0.3;
            filter: grayscale(100%);
        }
        
        .ui-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            pointer-events: all;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
        }
        
        /* √âCRANS OVERLAY */
        .game-screen.overlay {
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
        }
        
        .pause-content, .game-over-content {
            background: rgba(20, 20, 20, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
            max-width: 500px;
            width: 90%;
        }
        
        .pause-content h2, .game-over-content h2 {
            margin-bottom: 30px;
            font-size: 2rem;
        }
        
        .pause-stats, .final-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-item, .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-label {
            display: block;
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        
        .stat-value {
            display: block;
            color: #4ecdc4;
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .stat-icon {
            font-size: 1.2rem;
            margin-right: 8px;
        }
        
        .performance-message {
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid rgba(78, 205, 196, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            color: #4ecdc4;
        }
        
        .pause-buttons, .game-over-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        /* RESPONSIVE */
        @media (max-width: 768px) {
            .game-title {
                font-size: 2.5rem;
            }
            
            .difficulty-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .ui-top {
                flex-direction: column;
                gap: 10px;
            }
            
            .pause-content, .game-over-content {
                padding: 20px;
            }
        }
        
        /* BARRE DE PROGRESSION - CSS MANQUANT */
        .progress-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            text-align: center;
            z-index: 1000;
        }
        
        .progress-label {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .progress-bar {
            background: rgba(255, 255, 255, 0.1);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShine 2s infinite;
        }
        
        @keyframes progressShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .progress-text {
            color: #4ecdc4;
            font-size: 0.8rem;
            margin-top: 5px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* Responsive pour la barre de progression */
        @media (max-width: 768px) {
            .progress-container {
                width: 250px;
                bottom: 15px;
            }
            
            .progress-label, .progress-text {
                font-size: 0.8rem;
            }
        }
        
        @media (max-width: 480px) {
            .progress-container {
                width: 200px;
                bottom: 10px;
            }
            
            .progress-bar {
                height: 6px;
            }
        }
    </style>
</head>
<body>
    <!-- √âcran de d√©marrage -->
    <div id="start-screen" class="game-screen active">
        <div class="game-header">
            <h1 class="game-title">
                <span class="title-icon">‚öîÔ∏è</span>
                Verbe Slicer
            </h1>
            <p class="game-subtitle">Ma√Ætrisez les verbes irr√©guliers fran√ßais !</p>
        </div>

        <div style="color: white; text-align: center; margin: 20px;">
            <p>üéØ <strong>Objectif :</strong> Cliquez sur les verbes irr√©guliers qui tombent</p>
            <p>‚ö° <strong>Contr√¥les :</strong> Clic pour trancher, Espace pour pause</p>
            <p>üìà <strong>Progression :</strong> 5 niveaux de difficult√© croissante</p>
        </div>

        <div class="difficulty-selector">
            <h3>Choisissez votre difficult√© :</h3>
            <div class="difficulty-buttons">
                <button class="difficulty-btn" data-difficulty="facile">
                    <span class="difficulty-icon">üå±</span>
                    <span class="difficulty-name">Facile</span>
                </button>
                <button class="difficulty-btn active" data-difficulty="normal">
                    <span class="difficulty-icon">‚ö°</span>
                    <span class="difficulty-name">Normal</span>
                </button>
                <button class="difficulty-btn" data-difficulty="difficile">
                    <span class="difficulty-icon">üî•</span>
                    <span class="difficulty-name">Difficile</span>
                </button>
            </div>
        </div>

        <button id="start-game-btn" class="game-btn primary">
            <span class="btn-icon">üöÄ</span>
            Commencer l'aventure
        </button>
    </div>

    <!-- √âcran de jeu -->
    <div id="game-screen" class="game-screen">
        <div class="game-ui">
            <div class="ui-top">
                <div class="score-display">
                    <span class="score-label">Score</span>
                    <span id="score" class="score-value">0</span>
                </div>
                
                <div class="level-display">
                    <span class="level-label">Niveau</span>
                    <span id="level" class="level-value">1</span>
                    <span id="level-name" class="level-name">Infinitifs</span>
                </div>

                <div class="lives-display">
                    <span class="lives-label">Vies</span>
                    <div id="lives" class="lives-hearts">
                        <span class="heart">‚ù§Ô∏è</span>
                        <span class="heart">‚ù§Ô∏è</span>
                        <span class="heart">‚ù§Ô∏è</span>
                        <span class="heart">‚ù§Ô∏è</span>
                        <span class="heart">‚ù§Ô∏è</span>
                    </div>
                </div>

                <button id="pause-btn" class="ui-btn">‚è∏Ô∏è</button>
            </div>

            <div class="ui-bottom">
                <div class="progress-container">
                    <div class="progress-label">Progression vers le niveau suivant</div>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text" class="progress-text">0 / 25</div>
                </div>
            </div>
        </div>

        <canvas id="game-canvas"></canvas>
        <div id="particles-container"></div>
        <div id="floating-texts"></div>
    </div>

    <!-- √âcran de pause -->
    <div id="pause-screen" class="game-screen overlay">
        <div class="pause-content">
            <h2>‚è∏Ô∏è Jeu en pause</h2>
            <div class="pause-stats">
                <div class="stat-item">
                    <span class="stat-label">Score actuel</span>
                    <span id="pause-score" class="stat-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Niveau</span>
                    <span id="pause-level" class="stat-value">1</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Pr√©cision</span>
                    <span id="pause-accuracy" class="stat-value">100%</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Progression</span>
                    <span id="pause-progress" class="stat-value">0%</span>
                    <span id="pause-progress-text" class="stat-label">0 / 25</span>
                </div>
            </div>
            <div class="pause-buttons">
                <button id="resume-btn" class="game-btn primary">
                    <span class="btn-icon">‚ñ∂Ô∏è</span>
                    Reprendre
                </button>
                <button id="restart-btn" class="game-btn secondary">
                    <span class="btn-icon">üîÑ</span>
                    Red√©marrer
                </button>
                <button id="quit-btn" class="game-btn">
                    <span class="btn-icon">üè†</span>
                    Quitter
                </button>
                <button id="menu-games-btn" class="game-btn">
                    <span class="btn-icon">üéÆ</span>
                    Menu des jeux
                </button>
            </div>
        </div>
    </div>

    <!-- √âcran de fin -->
    <div id="game-over-screen" class="game-screen overlay">
        <div class="game-over-content">
            <h2 id="game-over-title">üéØ Partie termin√©e !</h2>
            
            <div class="final-stats">
                <div class="stat-card">
                    <span class="stat-icon">üèÜ</span>
                    <span class="stat-label">Score final</span>
                    <span id="final-score" class="stat-value">0</span>
                </div>
                <div class="stat-card">
                    <span class="stat-icon">üìä</span>
                    <span class="stat-label">Niveau atteint</span>
                    <span id="final-level" class="stat-value">1</span>
                </div>
                <div class="stat-card">
                    <span class="stat-icon">üéØ</span>
                    <span class="stat-label">Pr√©cision</span>
                    <span id="final-accuracy" class="stat-value">100%</span>
                </div>
                <div class="stat-card">
                    <span class="stat-icon">‚öîÔ∏è</span>
                    <span class="stat-label">Verbes tranch√©s</span>
                    <span id="verbs-sliced" class="stat-value">0</span>
                </div>
                <div class="stat-card">
                    <span class="stat-icon">‚è±Ô∏è</span>
                    <span class="stat-label">Temps de jeu</span>
                    <span id="game-time" class="stat-value">0:00</span>
                </div>
                <div class="stat-card">
                    <span class="stat-icon">üî•</span>
                    <span class="stat-label">Meilleure s√©rie</span>
                    <span id="best-streak" class="stat-value">0</span>
                </div>
            </div>

            <div id="performance-message" class="performance-message"></div>

            <div class="game-over-buttons">
                <button id="play-again-btn" class="game-btn primary">
                    <span class="btn-icon">üîÑ</span>
                    Rejouer
                </button>
                <button id="back-to-menu-btn" class="game-btn secondary">
                    <span class="btn-icon">üè†</span>
                    Menu principal
                </button>
            </div>
        </div>
    </div>

    <script>
        // Version modifi√©e du jeu qui force les donn√©es fallback
        class VerbeSlicerSimple {
            constructor() {
                console.log('üéÆ Initialisation Verbe Slicer Simple...');
                
                this.canvas = null;
                this.ctx = null;
                this.gameState = 'menu';
                this.difficulty = 'normal';
                
                // FORCE les donn√©es int√©gr√©es imm√©diatement - BASE ENRICHIE
                this.verbesData = {
                    verbesIrreguliers: {
                        infinitif: [
                            '√™tre', 'avoir', 'aller', 'faire', 'dire', 'pouvoir', 'voir', 'savoir', 
                            'vouloir', 'venir', 'prendre', 'mettre', 'devoir', 'partir', 'tenir',
                            'sortir', 'sentir', 'vivre', 'mourir', 'ouvrir', 'suivre', 'courir',
                            'servir', 'dormir', 'mentir', 'croire', 'boire', 'lire', '√©crire', 'conna√Ætre'
                        ],
                        participe_passe: [
                            '√©t√©', 'eu', 'all√©', 'fait', 'dit', 'pu', 'vu', 'su', 
                            'voulu', 'venu', 'pris', 'mis', 'd√ª', 'parti', 'tenu',
                            'sorti', 'senti', 'v√©cu', 'mort', 'ouvert', 'suivi', 'couru',
                            'servi', 'dormi', 'menti', 'cru', 'bu', 'lu', '√©crit', 'connu'
                        ],
                        futur: [
                            'serai', 'aurai', 'irai', 'ferai', 'dirai', 'pourrai', 'verrai', 'saurai', 
                            'voudrai', 'viendrai', 'prendrai', 'mettrai', 'devrai', 'partirai', 'tiendrai',
                            'sortirai', 'sentirai', 'vivrai', 'mourrai', 'ouvrirai', 'suivrai', 'courrai',
                            'servirai', 'dormirai', 'mentirai', 'croirai', 'boirai', 'lirai', '√©crirai', 'conna√Ætrai'
                        ],
                        imparfait: [
                            '√©tais', 'avais', 'allais', 'faisais', 'disais', 'pouvais', 'voyais', 'savais', 
                            'voulais', 'venais', 'prenais', 'mettais', 'devais', 'partais', 'tenais',
                            'sortais', 'sentais', 'vivais', 'mourais', 'ouvrais', 'suivais', 'courais',
                            'servais', 'dormais', 'mentais', 'croyais', 'buvais', 'lisais', '√©crivais', 'connaissais'
                        ],
                        subjonctif: [
                            'sois', 'aies', 'ailles', 'fasses', 'dises', 'puisses', 'voies', 'saches', 
                            'veuilles', 'viennes', 'prennes', 'mettes', 'doives', 'partes', 'tiennes',
                            'sortes', 'sentes', 'vives', 'meures', 'ouvres', 'suives', 'coures',
                            'serves', 'dormes', 'mentes', 'croies', 'boives', 'lises', '√©crives', 'connaisses'
                        ],
                        conditionnel: [
                            'serais', 'aurais', 'irais', 'ferais', 'dirais', 'pourrais', 'verrais', 'saurais', 
                            'voudrais', 'viendrais', 'prendrais', 'mettrais', 'devrais', 'partirais', 'tiendrais',
                            'sortirais', 'sentirais', 'vivrais', 'mourrais', 'ouvrirais', 'suivrais', 'courrais',
                            'servirais', 'dormirais', 'mentirais', 'croirais', 'boirais', 'lirais', '√©crirais', 'conna√Ætrais'
                        ]
                    },
                    motsDivers: [
                        // Verbes r√©guliers infinitifs
                        'parler', 'aimer', 'donner', 'porter', 'arriver', 'rester', 'entrer', 'montrer',
                        'passer', 'regarder', 'trouver', 'appeler', 'demander', 'garder', 'attendre',
                        'chanter', 'danser', 'jouer', 'manger', 'travailler', '√©tudier', 'marcher',
                        'chercher', '√©couter', 'habiter', 'finir', 'choisir', 'r√©ussir', 'grandir',
                        // Participes pass√©s r√©guliers
                        'parl√©', 'aim√©', 'donn√©', 'port√©', 'arriv√©', 'rest√©', 'entr√©', 'montr√©',
                        'pass√©', 'regard√©', 'trouv√©', 'appel√©', 'demand√©', 'gard√©', 'attendu',
                        'chant√©', 'dans√©', 'jou√©', 'mang√©', 'travaill√©', '√©tudi√©', 'march√©',
                        'cherch√©', '√©cout√©', 'habit√©', 'fini', 'choisi', 'r√©ussi', 'grandi',
                        // Conditionnels r√©guliers
                        'parlerais', 'aimerais', 'donnerais', 'porterais', 'arriverais', 'resterais', 'entrerais', 'montrerais',
                        'passerais', 'regarderais', 'trouverais', 'appellerais', 'demanderais', 'garderais', 'attendrais',
                        'chanterais', 'danserais', 'jouerais', 'mangerais', 'travaillerais', '√©tudierais', 'marcherais',
                        'chercherais', '√©couterais', 'habiterais', 'finirais', 'choisirais', 'r√©ussirais', 'grandirais'
                    ]
                };
                console.log('üìä Donn√©es fallback enrichies charg√©es - Mode autonome confirm√©');
                this.currentVerbs = [];
                this.isDataLoaded = true; // FORCE √† true
                
                // Stats de jeu
                this.score = 0;
                this.level = 1;
                this.lives = 5;
                this.maxLives = 5;
                this.verbsSliced = 0;
                this.totalClicks = 0;
                this.correctClicks = 0;
                this.currentStreak = 0;
                this.bestStreak = 0;
                this.gameStartTime = 0;
                this.gameTime = 0;
                
                console.log('üéÆ Stats initiales:', {
                    lives: this.lives,
                    maxLives: this.maxLives,
                    score: this.score
                });
                
                // Param√®tres de jeu
                this.gameSpeed = 60;
                this.spawnRate = 0.03;
                this.wordSpeed = 1;
                this.maxWords = 8;
                this.lastSpawnTime = 0;
                this.spawnInterval = 1000;
                
                // Niveaux - SEUILS AJUST√âS POUR PROGRESSION PLUS RAPIDE
                this.levels = [
                    { name: 'Infinitifs', threshold: 0, verbType: 'infinitif', color: '#3498db' },
                    { name: 'Participes pass√©s', threshold: 10, verbType: 'participe_passe', color: '#9b59b6' },
                    { name: 'Futur', threshold: 25, verbType: 'futur', color: '#e67e22' },
                    { name: 'Imparfait', threshold: 45, verbType: 'imparfait', color: '#e74c3c' },
                    { name: 'Subjonctif', threshold: 70, verbType: 'subjonctif', color: '#f39c12' },
                    { name: 'Conditionnel', threshold: 100, verbType: 'conditionnel', color: '#8e44ad' }
                ];
                
                this.difficultySettings = {
                    facile: { speedMultiplier: 0.8, spawnMultiplier: 0.8, maxWords: 5 },
                    normal: { speedMultiplier: 1.0, spawnMultiplier: 1.0, maxWords: 10 },
                    difficile: { speedMultiplier: 2, spawnMultiplier: 2, maxWords: 20 }
                };
                
                // Effets visuels
                this.fallingWords = [];
                this.particles = [];
                this.floatingTexts = [];
                this.sliceEffects = [];
                
                this.init();
            }
            
            async init() {
                try {
                    this.setupEventListeners();
                    
                    this.initializeCurrentVerbs();
                    
                    this.setupCanvas();
                    
                    console.log('‚úÖ Verbe Slicer Simple initialis√© !');
                } catch (error) {
                    console.error('‚ùå Erreur:', error);
                }
            }
            
            setupEventListeners() {
                const startBtn = document.getElementById('start-game-btn');
                if (startBtn) {
                    startBtn.addEventListener('click', () => this.startGame());
                }
                
                const difficultyBtns = document.querySelectorAll('.difficulty-btn');
                difficultyBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        e.target.closest('.difficulty-btn').classList.add('active');
                        this.difficulty = e.target.closest('.difficulty-btn').dataset.difficulty;
                    });
                });
                
                const pauseBtn = document.getElementById('pause-btn');
                const resumeBtn = document.getElementById('resume-btn');
                const restartBtn = document.getElementById('restart-btn');
                const quitBtn = document.getElementById('quit-btn');
                const playAgainBtn = document.getElementById('play-again-btn');
                const backToMenuBtn = document.getElementById('back-to-menu-btn');
                const menuGamesBtn = document.getElementById('menu-games-btn');
                
                if (pauseBtn) pauseBtn.addEventListener('click', () => this.togglePause());
                if (resumeBtn) resumeBtn.addEventListener('click', () => this.togglePause());
                if (restartBtn) restartBtn.addEventListener('click', () => this.startGame());
                if (quitBtn) quitBtn.addEventListener('click', () => this.quitToMenu());
                if (playAgainBtn) playAgainBtn.addEventListener('click', () => this.startGame());
                if (backToMenuBtn) backToMenuBtn.addEventListener('click', () => this.quitToMenu());
                if (menuGamesBtn) menuGamesBtn.addEventListener('click', () => this.goToGamesMenu());
                
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'Space':
                            e.preventDefault();
                            if (this.gameState === 'playing' || this.gameState === 'paused') {
                                this.togglePause();
                            }
                            break;
                        case 'KeyR':
                            if (this.gameState === 'playing' || this.gameState === 'paused') {
                                this.startGame();
                            }
                            break;
                    }
                });
            }
            
            initializeCurrentVerbs() {
                const currentLevel = this.getCurrentLevel();
                const irregularVerbs = this.verbesData.verbesIrreguliers[currentLevel.verbType] || [];
                const regularWords = this.verbesData.motsDivers || [];
                this.currentVerbs = [...irregularVerbs, ...regularWords];
                
                // V√âRIFICATION que nous utilisons bien les donn√©es fallback
                console.log(` Verbes initialis√©s: ${this.currentVerbs.length} mots`);
                console.log(` Niveau ${currentLevel.name} (${currentLevel.verbType}):`);
                console.log(`  - ${irregularVerbs.length} verbes irr√©guliers: ${irregularVerbs.slice(0, 5).join(', ')}...`);
                console.log(`  - ${regularWords.length} mots r√©guliers: ${regularWords.slice(0, 5).join(', ')}...`);
                console.log('üîí SOURCE: Donn√©es fallback int√©gr√©es (autonome)');
            }
            
            setupCanvas() {
                this.canvas = document.getElementById('game-canvas');
                if (!this.canvas) {
                    throw new Error('Canvas non trouv√©');
                }
                
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();
                
                window.addEventListener('resize', () => this.resizeCanvas());
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            startGame() {
                console.log('üöÄ D√©marrage du jeu...');
                
                console.log('üîç √âtat avant reset:', {
                    lives: this.lives,
                    maxLives: this.maxLives,
                    gameState: this.gameState
                });
                
                this.resetGameStats();
                
                console.log('üîç √âtat apr√®s reset:', {
                    lives: this.lives,
                    maxLives: this.maxLives,
                    gameState: this.gameState
                });
                
                this.initializeCurrentVerbs();
                this.gameState = 'playing';
                this.gameStartTime = Date.now();
                this.lastSpawnTime = Date.now();
                
                console.log('üîç √âtat final avant showScreen:', {
                    lives: this.lives,
                    gameState: this.gameState,
                    currentVerbs: this.currentVerbs.length
                });
                
                this.showScreen('game-screen');
                
                console.log('üîÑ Lancement gameLoop...');
                this.gameLoop();
            }
            
            resetGameStats() {
                console.log('üîÑ R√©initialisation des stats...');
                this.score = 0;
                this.level = 1;
                this.lives = this.maxLives; // Assurer que maxLives est bien d√©fini
                this.verbsSliced = 0;
                this.totalClicks = 0;
                this.correctClicks = 0;
                this.currentStreak = 0;
                this.bestStreak = 0;
                this.fallingWords = [];
                this.particles = [];
                this.floatingTexts = [];
                this.sliceEffects = [];
                
                console.log('üîÑ Vies apr√®s reset:', this.lives, 'maxLives:', this.maxLives);
                
                const settings = this.difficultySettings[this.difficulty];
                this.wordSpeed = 1 * settings.speedMultiplier;
                this.spawnRate = 0.02 * settings.spawnMultiplier;
                this.maxWords = settings.maxWords;
                this.spawnInterval = 1000 / settings.spawnMultiplier;
                
                console.log('üéöÔ∏è Param√®tres difficult√©:', this.difficulty, settings);
                
                this.updateUI();
            }
            
            getCurrentLevel() {
                for (let i = this.levels.length - 1; i >= 0; i--) {
                    if (this.score >= this.levels[i].threshold) {
                        return this.levels[i];
                    }
                }
                return this.levels[0];
            }
            
            gameLoop() {
                if (this.gameState !== 'playing') return;
                
                this.update();
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                this.gameTime = Date.now() - this.gameStartTime;
                
                // DEBUG: V√©rifier les vies
                if (this.lives <= 0) {
                    console.log('‚ùå Game Over d√©tect√©, vies:', this.lives);
                    this.gameOver();
                    return;
                }
                
                // Spawn de nouveaux mots
                const now = Date.now();
                if (now - this.lastSpawnTime > this.spawnInterval && this.fallingWords.length < this.maxWords) {
                    this.spawnWord();
                    this.lastSpawnTime = now;
                }
                
                // Mise √† jour des mots qui tombent
                this.updateFallingWords();
                this.updateParticles();
                this.updateFloatingTexts();
            }
            
            spawnWord() {
                if (this.currentVerbs.length === 0) return;
                
                const word = this.currentVerbs[Math.floor(Math.random() * this.currentVerbs.length)];
                const currentLevel = this.getCurrentLevel();
                const isIrregular = this.isIrregularVerb(word);
                
                // COULEURS UNIFORMIS√âES - Plus de distinction visuelle
                let wordColor = currentLevel.color || '#ffffff'; // Couleur uniforme bas√©e sur le niveau
                
                this.fallingWords.push({
                    text: word,
                    x: Math.random() * (this.canvas.width - 200) + 100,
                    y: -50,
                    speed: this.wordSpeed + Math.random() * 0.5,
                    isIrregular: isIrregular,
                    color: wordColor, // Couleur uniforme
                    rotation: 0,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                });
                
                console.log(`‚ú® Mot spawn√©: "${word}" (${isIrregular ? 'irr√©gulier' : 'r√©gulier'}) - Couleur uniforme: ${wordColor}`);
            }
            
            isIrregularVerb(word) {
                return Object.values(this.verbesData.verbesIrreguliers).some(verbs => 
                    verbs.includes(word)
                );
            }
            
            updateFallingWords() {
                this.fallingWords.forEach((word, index) => {
                    word.y += word.speed;
                    word.rotation += word.rotationSpeed;
                    
                    if (word.y > this.canvas.height + 50) {
                        this.fallingWords.splice(index, 1);
                        if (word.isIrregular) {
                            console.log('üíî Verbe irr√©gulier rat√©:', word.text, 'Vies avant:', this.lives);
                            this.loseLife();
                            console.log('üíî Vies apr√®s:', this.lives);
                        }
                    }
                });
            }
            
            handleClick(event) {
                if (this.gameState !== 'playing') return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                this.totalClicks++;
                
                this.fallingWords.forEach((word, index) => {
                    if (this.isPointInWord(x, y, word)) {
                        this.handleWordClick(word, index);
                    }
                });
            }
            
            isPointInWord(x, y, word) {
                this.ctx.font = '30px Arial';
                const metrics = this.ctx.measureText(word.text);
                const wordWidth = metrics.width;
                const wordHeight = 30;
                
                return x >= word.x - wordWidth/2 && 
                       x <= word.x + wordWidth/2 && 
                       y >= word.y - wordHeight/2 && 
                       y <= word.y + wordHeight/2;
            }
            
            handleWordClick(word, index) {
                this.totalClicks++;
                this.fallingWords.splice(index, 1);
                
                if (word.isIrregular) {
                    // Bon clic sur verbe irr√©gulier
                    this.score++;
                    this.verbsSliced++;
                    this.correctClicks++;
                    this.currentStreak++;
                    this.bestStreak = Math.max(this.bestStreak, this.currentStreak);
                    
                    // R√©cup√©ration d'un coeur et affichage du texte combin√©
                    let mainText = '+1';
                    if (this.lives < this.maxLives) {
                        this.lives++;
                        mainText = '+1 ‚ù§Ô∏è'; // Combiner les deux messages en un seul
                        console.log('üíö Coeur r√©cup√©r√© ! Vies actuelles:', this.lives);
                    }
                    
                    // Un seul texte flottant
                    this.addFloatingText(word.x, word.y, mainText, 'success');
                    console.log('‚úÖ Verbe irr√©gulier tranch√©:', word.text, 'Score:', this.score);
                    
                    // V√©rifier changement de niveau
                    this.checkLevelUp();
                } else {
                    // Mauvais clic sur verbe r√©gulier
                    this.currentStreak = 0;
                    this.loseLife();
                    this.addFloatingText(word.x, word.y, 'Erreur !', 'error');
                    console.log('‚ùå Erreur: verbe r√©gulier cliqu√©:', word.text, 'Vies restantes:', this.lives);
                }
                
                this.updateUI();
            }
            
            checkLevelUp() {
                const previousLevel = this.level;
                const currentLevel = this.getCurrentLevel();
                const newLevel = this.levels.indexOf(currentLevel) + 1;
                
                if (newLevel > this.level) {
                    this.level = newLevel;
                    this.initializeCurrentVerbs(); // Recharger les verbes pour le nouveau niveau
                    
                    console.log('üî• NIVEAU UP !', {
                        previousLevel,
                        newLevel: this.level,
                        currentLevelName: currentLevel.name,
                        score: this.score
                    });
                    
                    // Affichage visuel du niveau up
                    this.showLevelUpEffect();
                }
            }
            
            showLevelUpEffect() {
                const currentLevel = this.getCurrentLevel();
                
                // Cr√©er l'effet de niveau up
                const effectElement = document.createElement('div');
                effectElement.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: linear-gradient(135deg, ${currentLevel.color}, #ffd700);
                        color: white;
                        padding: 30px 50px;
                        border-radius: 20px;
                        font-size: 2rem;
                        font-weight: bold;
                        text-align: center;
                        z-index: 10000;
                        animation: levelUpPulse 2s ease-out;
                        box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
                        border: 3px solid #ffd700;
                    ">
                        üéâ NIVEAU ${this.level} üéâ<br>
                        <span style="font-size: 1.2rem; color: #fff;">${currentLevel.name}</span>
                    </div>
                `;
                
                // Ajouter l'animation CSS temporairement
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes levelUpPulse {
                        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(effectElement);
                
                // Supprimer l'effet apr√®s l'animation
                setTimeout(() => {
                    document.body.removeChild(effectElement);
                    document.head.removeChild(style);
                }, 2000);
            }
            
            loseLife() {
                this.lives--;
                console.log('üíî Vie perdue, vies restantes:', this.lives);
                this.updateLivesDisplay();
                if (this.lives <= 0) {
                    console.log('üíÄ Plus de vies, Game Over');
                    this.gameOver();
                }
            }
            
            addFloatingText(x, y, text, type) {
                this.floatingTexts.push({
                    x: x, y: y, text: text, type: type,
                    life: 1, decay: 0.015, vy: -2
                });
            }
            
            updateParticles() {
                this.particles.forEach((particle, index) => {
                    particle.life -= particle.decay;
                    if (particle.life <= 0) {
                        this.particles.splice(index, 1);
                    }
                });
            }
            
            updateFloatingTexts() {
                this.floatingTexts.forEach((text, index) => {
                    text.y += text.vy;
                    text.life -= text.decay;
                    if (text.life <= 0) {
                        this.floatingTexts.splice(index, 1);
                    }
                });
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.renderFallingWords();
                this.renderFloatingTexts();
            }
            
            renderFallingWords() {
                this.fallingWords.forEach(word => {
                    this.ctx.save();
                    this.ctx.translate(word.x, word.y);
                    this.ctx.rotate(word.rotation);
                    
                    // Ombre port√©e uniforme
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.font = 'bold 30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(word.text, 2, 2);
                    
                    // Texte principal uniforme - PLUS DE DISTINCTION VISUELLE
                    this.ctx.fillStyle = word.color;
                    this.ctx.fillText(word.text, 0, 0);
                    
                    // SUPPRESSION de tous les effets visuels distinctifs
                    // Plus d'√©mojis, plus de halos, plus de bordures diff√©rentes
                    // Tous les mots ont la m√™me apparence pour augmenter la difficult√©
                    
                    this.ctx.restore();
                });
            }
            
            renderFloatingTexts() {
                this.floatingTexts.forEach(text => {
                    this.ctx.save();
                    this.ctx.globalAlpha = text.life;
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.textAlign = 'center';
                    
                    this.ctx.fillStyle = text.type === 'success' ? '#27ae60' : '#e74c3c';
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeText(text.text, text.x, text.y);
                    this.ctx.fillText(text.text, text.x, text.y);
                    
                    this.ctx.restore();
                });
            }
            
            updateUI() {
                const scoreEl = document.getElementById('score');
                const levelEl = document.getElementById('level');
                const levelNameEl = document.getElementById('level-name');
                
                if (scoreEl) scoreEl.textContent = this.score;
                if (levelEl) levelEl.textContent = this.level;
                if (levelNameEl) levelNameEl.textContent = this.getCurrentLevel().name;
                
                this.updateLivesDisplay();
                this.updateProgressBar();
            }
            
            updateLivesDisplay() {
                const hearts = document.querySelectorAll('.heart');
                console.log('üíñ Mise √† jour affichage vies:', this.lives, 'coeurs trouv√©s:', hearts.length);
                hearts.forEach((heart, index) => {
                    if (index < this.lives) {
                        heart.classList.remove('lost');
                    } else {
                        heart.classList.add('lost');
                    }
                });
            }
            
            updateProgressBar() {
                const currentLevel = this.getCurrentLevel();
                const currentLevelIndex = this.levels.indexOf(currentLevel);
                const nextLevel = this.levels[currentLevelIndex + 1];
                
                if (nextLevel) {
                    const pointsInCurrentLevel = this.score - currentLevel.threshold;
                    const pointsNeededForNext = nextLevel.threshold - currentLevel.threshold;
                    const progressPercentage = Math.min((pointsInCurrentLevel / pointsNeededForNext) * 100, 100);
                    
                    const progressFill = document.getElementById('progress-fill');
                    const progressText = document.getElementById('progress-text');
                    
                    if (progressFill) {
                        progressFill.style.width = progressPercentage + '%';
                    }
                    
                    if (progressText) {
                        progressText.textContent = `${pointsInCurrentLevel} / ${pointsNeededForNext}`;
                    }
                    
                    console.log('üîÑ Progression mise √† jour:', {
                        currentLevel: currentLevel.name,
                        score: this.score,
                        pointsInCurrentLevel,
                        pointsNeededForNext,
                        percentage: progressPercentage.toFixed(1) + '%'
                    });
                } else {
                    // Niveau maximum atteint
                    const progressFill = document.getElementById('progress-fill');
                    const progressText = document.getElementById('progress-text');
                    
                    if (progressFill) {
                        progressFill.style.width = '100%';
                    }
                    
                    if (progressText) {
                        progressText.textContent = 'Niveau MAX';
                    }
                    
                    console.log('üèÜ Niveau maximum atteint !');
                }
            }
            
            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    this.updatePauseStats();
                    this.showScreen('pause-screen');
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    this.showScreen('game-screen');
                    this.gameLoop();
                }
            }
            
            updatePauseStats() {
                const accuracy = this.totalClicks > 0 ? Math.round((this.correctClicks / this.totalClicks) * 100) : 100;
                
                // Mise √† jour des stats de pause
                const pauseScore = document.getElementById('pause-score');
                const pauseLevel = document.getElementById('pause-level');
                const pauseAccuracy = document.getElementById('pause-accuracy');
                const pauseProgress = document.getElementById('pause-progress');
                const pauseProgressText = document.getElementById('pause-progress-text');
                
                if (pauseScore) pauseScore.textContent = this.score;
                if (pauseLevel) pauseLevel.textContent = this.level;
                if (pauseAccuracy) pauseAccuracy.textContent = accuracy + '%';
                
                // Calcul de la progression
                const currentLevel = this.getCurrentLevel();
                const currentLevelIndex = this.levels.indexOf(currentLevel);
                const nextLevel = this.levels[currentLevelIndex + 1];
                
                if (nextLevel) {
                    const pointsInCurrentLevel = this.score - currentLevel.threshold;
                    const pointsNeededForNext = nextLevel.threshold - currentLevel.threshold;
                    const progressPercentage = Math.min((pointsInCurrentLevel / pointsNeededForNext) * 100, 100);
                    
                    if (pauseProgress) pauseProgress.textContent = Math.round(progressPercentage) + '%';
                    if (pauseProgressText) pauseProgressText.textContent = `${pointsInCurrentLevel} / ${pointsNeededForNext}`;
                } else {
                    if (pauseProgress) pauseProgress.textContent = '100%';
                    if (pauseProgressText) pauseProgressText.textContent = 'Niveau MAX';
                }
            }
            
            quitToMenu() {
                this.gameState = 'menu';
                this.showScreen('start-screen');
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                this.updateFinalStats();
                this.showScreen('game-over-screen');
            }
            
            updateFinalStats() {
                const accuracy = this.totalClicks > 0 ? Math.round((this.correctClicks / this.totalClicks) * 100) : 100;
                const gameTimeSeconds = Math.floor(this.gameTime / 1000);
                const minutes = Math.floor(gameTimeSeconds / 60);
                const seconds = gameTimeSeconds % 60;
                
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('final-level').textContent = this.level;
                document.getElementById('final-accuracy').textContent = accuracy + '%';
                document.getElementById('verbs-sliced').textContent = this.verbsSliced;
                document.getElementById('game-time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('best-streak').textContent = this.bestStreak;
            }
            
            showScreen(screenId) {
                console.log('üñ•Ô∏è Changement d\'√©cran vers:', screenId);
                
                const screens = document.querySelectorAll('.game-screen');
                console.log('üñ•Ô∏è √âcrans trouv√©s:', screens.length);
                
                // Masquer tous les √©crans
                screens.forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.display = 'none'; // Force masquage
                    screen.style.opacity = '0'; // Force opacit√© 0
                    console.log('üì∫ Masquage:', screen.id);
                });
                
                // Afficher l'√©cran cible
                const targetScreen = document.getElementById(screenId);
                if (targetScreen) {
                    targetScreen.classList.add('active');
                    
                    // Force l'affichage selon le type d'√©cran
                    if (targetScreen.classList.contains('overlay')) {
                        targetScreen.style.display = 'flex';
                        console.log('üîç √âcran overlay affich√© en flex:', screenId);
                    } else {
                        targetScreen.style.display = 'block';
                        console.log('üîç √âcran normal affich√© en block:', screenId);
                    }
                    
                    // CORRECTION CRITIQUE: Force l'opacit√© √† 1
                    targetScreen.style.opacity = '1 !important';
                    targetScreen.style.visibility = 'visible !important';
                    
                    console.log('‚úÖ √âcran affich√©:', screenId);
                    
                    // V√©rification suppl√©mentaire avec double contr√¥le
                    setTimeout(() => {
                        const computedStyle = window.getComputedStyle(targetScreen);
                        console.log('üé® Style calcul√© pour', screenId, ':', {
                            display: computedStyle.display,
                            visibility: computedStyle.visibility,
                            opacity: computedStyle.opacity
                        });
                        
                        // Double v√©rification - forcer encore si n√©cessaire
                        if (parseFloat(computedStyle.opacity) < 0.9) {
                            console.log('‚ö†Ô∏è Opacit√© faible d√©tect√©e, correction forc√©e');
                            targetScreen.style.setProperty('opacity', '1', 'important');
                            targetScreen.style.setProperty('visibility', 'visible', 'important');
                            targetScreen.style.setProperty('display', targetScreen.classList.contains('overlay') ? 'flex' : 'block', 'important');
                        }
                    }, 100);
                } else {
                    console.error('‚ùå √âcran non trouv√©:', screenId);
                }
            }
            
            goToGamesMenu() {
                // Impl√©mentation de la fonction goToGamesMenu
                console.log('üéÆ Aller au menu des jeux');
            }
        }
        
        // Initialiser le jeu
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üìÑ DOM charg√©, initialisation...');
            const game = new VerbeSlicerSimple();
            window.game = game;
        });
    </script>
</body>
</html> 